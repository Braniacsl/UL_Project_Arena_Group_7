name: CI/CD for FYP Showcase Platform (Backend)

on:
  push:
    branches:
      - main
    paths:
<<<<<<< HEAD
      - 'backend/**' # Only run when files in the backend change
=======
      - 'backend/**'
      - 'fyp_portal/**'
>>>>>>> a4a70f0 (Organizing Monorepo)
      - '.forgejo/workflows/backend_deploy.yaml'
  workflow_dispatch:

jobs:
  test_and_build_backend:
    name: Test & Build Rust Backend
    # Run if triggered manually or if 'backend/' files were modified/added
    if: |
      github.event_name == 'workflow_dispatch' ||
      contains(toJson(github.event.commits.*.modified), 'backend/') ||
      contains(toJson(github.event.commits.*.added), 'backend/')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # 1. Install Rust Toolchain (Required for your project)
      - name: Install Rust Toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          override: true

      # 2. Cache Rust Dependencies for speed
      - name: Cache Cargo Dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            backend/target
          # Key based on the lock file to ensure cache invalidates correctly
          key: ${{ runner.os }}-cargo-${{ hashFiles('backend/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      # 3. Build the backend in release mode (verifies compilation and SQLx)
      - name: Build Backend (Release)
        run: cargo build --release --manifest-path backend/Cargo.toml

      - name: Set Testing Environment Variables
        run: |
          echo "APP_ENV=ci" >> $GITHUB_ENV
          echo "DATABASE_URL=postgres://postgres:password@localhost:5432/fyp" >> $GITHUB_ENV
          # Note: We assume your Rust code will default S3/MinIO to a testing mode
          # based on APP_ENV=ci, or you pass MinIO credentials here if necessary.
          # For simplicity, we are relying on your app's internal test/ci configuration.

      # 4. Run Unit and Integration Tests
      - name: Run All Tests
        run: cargo test --manifest-path backend/Cargo.toml

      # 5. Build Docker Image (Optional: For pre-deployment verification)
      - name: Verify Docker Image Build
        run: docker build -t project-arena-backend -f backend/Dockerfile backend/

  deploy_services: # Rename the job to reflect multiple deployments
    name: Deploy All Services to Render
    runs-on: ubuntu-latest
    needs: test_and_build_backend
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Log in to Docker Hub

      - name: Build and Push Rust Image

      - name: Trigger RUST Deployment Hook
        run: curl -X POST -fail -s ${{ secrets.RENDER_DEPLOY_HOOK }}

      - name: Build and Push Django Image
        run: docker build -f fyp_portal/Dockerfile.django -t ${{ secrets.DOCKER_REPO }}:django ./fyp_portal && docker push ${{ secrets.DOCKER_REPO }}:django

      - name: Trigger DJANGO Deployment Hook
        run: curl -X POST -fail -s ${{ secrets.RENDER_DJANGO_HOOK }}
